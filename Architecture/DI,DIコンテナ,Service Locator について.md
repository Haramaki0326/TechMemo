# DI,DIコンテナ,Service Locator について
## new 不吉な臭い


## 依存について


## DI(Dependency Injection)

・依存を減らすにはインターフェースを利用する（逆にDIをするからって依存がなくなるわけではない。例えばインターフェースではなく実装クラスをInjectされたら密結合になる）
【インターフェースをDI（とかFactory で生成）すると密結合を避けれる】が正解かも

DIを使わずにインターフェースを利用するには結局内部で実装インスタンスをnewするしかないわけだけど、それってつまり密結合なんだよな


## Service Locator パターン
Servcie Locatorの問題点

①依存関係が分からない
→サービスロケータの場合コンストラクタの引数はない。
コンストラクタDIならシグネチャから必要なオブジェクトが分かるが、サービスロケータの場合だとそれが分からない。依存関係を見るにはクラスの中を見ないといけない。

② テストの維持が難しい
クラスに新たなフィールドが追加された場合、テストコードも書き換える必要がある。SLパターンの場合、テストコードの中に、SLにインスタンスを設定する処理を書くことになるが、新しいフィールド用の設定を書き忘れてしまうと、テスト実行時まで問題が発覚しないことになる。


## DIコンテナ
DIコンテナを使えばこれは解決されるらしい

①クラスを定義する際、コンストラクタDIを使う
→これにより外部からも依存関係は一目瞭然

②コンパイル時にエラー検出可能
フィールドが追加されることにより、コンストラクタの引数は変わる。
もしテストコードにその反映を忘れてしまった場合、コンパイルが通らないので即間違いに気付くことができる。

上記①、②はDIコンテナの話ではなく
コンストラクタDIの話
ただ、コンストラクタDIの場合だと、引数が変わった場合に呼び出し元全ての記述をそれに合わせないといけなくなり大変面倒

そこで登場するのがDI（IoC）コンテナ
ClientクラスからIServiceクラスを呼び出したいときに、

Client→IoC呼び出し
→IoCがIServcie の具象化およびインスタンス取得
→IoCがServcieをClientにreturn
→ClientはServcieインスタンスを利用

という流れ