# 設計・開発チートシート

## キーワード
- SOLID原則
  - 単一責任の原則
    - 「クラスを変更する理由は一つ以上存在してはならない」という原則
    - ①明瞭性を高めるため、1責務1メソッドに分割する。
      - 明瞭性を高めると、コードの読みやすさが向上する。
    - ②抽象化を高めるため、責務にインターフェイスを適用する。
      - 抽象化を高めることで、ソフトウェア変更の要求に対応しやすくなる。
  - 開放/閉鎖の原則
    - 拡張に対して開かれている
    - 修正に対して閉じている
    - ★既存のコードはできる限り触らず、クラスのメンバ変数やインターフェイスの派生クラス追加などで対応できるように設計すること。
      - 修正に閉じた箇所は、如何に抽象化するために、インターフェイス・ジェネリック・テーブルを活用するかにかかっている。
  - リスコフの置換原則
    - 親クラス（Base）、子クラス（Derived）、呼び出し側（Client）
    - リスコフの置換原則：ClientがBaseを利用している箇所すべてに対し子クラスで置換したとしても安全であるべきだ
    - そのためには、BaseとDerivedとの間に、「is-a関係」が成り立っていなければならない
    - 「is-a関係」は単純な単純にメソッドのシグネチャが同じであればいいわけではない
    - クラスとしての責務を引き継がなければならない
    - そこで用いられる具体的な基準が
      - 契約に関するルール（「事前条件」「事後条件」「不変条件」）
      - 変性に関するルール（「戻り値＝共変」「引数＝反変」）
        - C#のオーバーライドメソッドに関して、その戻り値も引数も不変である。そのため、特別に対処する必要はない
        - C#でクラス変性を意識するのは、ジェネリックインターフェースとデリゲートに対してのみ。
  - インターフェース分離の原則
    - クライアントに、クライアントが利用しないメソッドへの依存を強制してはならない。
      - 利用しないメソッドに依存してしまうと、クライアントはそういったメソッドの変更の影響を受けやすくなってしまう。＝無駄にテストする必要が出てくる。
    - 分離方法
        - 委譲
        - インタフェースの多重継承
          - 線形継承は不必要に依存してしまうため、アンチパターン。

  - 依存性反転の原則
    - 上位のモジュールは下位のモジュールに依存してはならない。どちらのモジュールも「抽象」に依存するべきである。
    - 「抽象」は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存するべきである
    - 上位モジュールに依存しない場合のメリットとして、
      - ユニットテストがしやすい。
      - 別の実装に入れ替えやすい(再利用性が高い)
- DI
  - コンストラクタDI
  - DIコンテナ
  - アンチパターン
    - サービスロケータ
    - Illegitimate Injection
- デザインパターン
  - Null Object パターン
  - Strategy パターン
- 継承について
  - 無闇な継承は単一責務の原則（SRP）に違反する
  - 継承より委譲（転送）
  - インターフェース、コンストラクタDI、疎結合の実現
  - 継承するならリスコフの置換原則を守る